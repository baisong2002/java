概述：
  反射是被视为动态语言的关键，反射机制允许程序在执行器借助Reflection(反射) API取得任何类的内部信息，并能直接操作任意对象的内部属性方法
      动态语言：在运行时可以改变其内部结构的语言：例如：新的函数、对象、甚至代码可以被引进，已有的函数可以改变别删除或其他结构上的变化。
                在运行时代码可以根据某些条件改变自身结构
                javascript、php
      静态语言:运行时结构不可变的语言       java、c、c++
  加载完类之后，在堆内存的方法区就产生了一个Class类型的对象(一个类只能有一个Class对象)，这个对象就包含了完整的类的结构信息。可以通过这个对象看到类的结构
正常方式: 引入需要的"包类"名称---->通过new实例化---->取得实例化对象
反射方式：实例化对象---->getClass()方法---->得到完整的"包类"名称
反射功能：
 判断任意对象的类
 构造任意类的对象
 判断任意类所具有的成员变量和方法
 获取泛型信息
 调用任意一个对象的成员变量和方法
 处理注解
 生成生态代理
关于java.long.Class的理解：
 1、类的加载过程：
     程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)，接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到
    内存中，此过程就成为类的加载。加载到内存中的类，我们称为运行时类，此运行时类，就作为Class的一个实例。
 2、Class的实力就对应一个运行时类。
       加载到内存中的运行时类，会缓存一定时间。在此时间之内，我们可以通过不同的方式来获取运行时类
 3、获取Class类实例：
        //方式一：调用运行时类的属性
        Class<Person> class1 = Person.class;
        System.out.println(class1);
        //方式二:通过运行时类的对象，调用getClass()
        Person p1 = new Person();
        Class class2 = p1.getClass();
        System.out.println(class2);
         //方式三:调用Class的静态方法：forName(String classPath) String classPath:类所在的包名
        Class class3 = Class.forName("Classtest1.Person");
        System.out.println(class3);

        System.out.println(class1==class2);//true
        System.out.println(class1==class3);//true
       //方式四：使用类的加载器：ClassLoader
        ClassLoader classLoader = Classtest.class.getClassLoader();
        Class<?> class4 = classLoader.loadClass("Classtest1.Classtest");
        System.out.println(class4);
        System.out.println(class1==class4);
4、Class对应的结构：
 class:
   外部类、内部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类
 interface:接口
 []:数组
   只要数组的元素类型和维度一样，就是同一个Class
 enum:枚举
 annotation:注解@interface
 primitive type:基本数据类型
 void
 ***********************************************************************
    /*
    Properties:用来读取配置文件
     */
    @Test
    public void A() throws IOException {
        Properties p = new Properties();
        //此时的文件默认在当前的module下。
        //方式一：
        //    FileInputStream f = new FileInputStream("jdbc.properties");
        //  p.load(f);
        //方式二：使用ClassLoader
        //配置文件默认识别为：当前module的src下
        ClassLoader classLoader = Classtest2.class.getClassLoader();
        InputStream is = classLoader.getResourceAsStream("A.properties");
        p.load(is);


        String user = p.getProperty("user");
        String passwad = p.getProperty("password");
        System.out.println(user);
        System.out.println(passwad);
    }
}
*************************************************************************************************************
一、创建运行时类的对象
**************************************************************************************************
 Class class1 = Person.class;
        /*newInstance():调用此方法创建运行时类的对象。内部调用了运行时的空参构造器
        要想此方法正常创建运行时类的对象，要求：
        1、运行时类必须提供空参的构造器
        2、空参构造器的访问权限得够。通常设置为public

        在javabean中要求提供public的空参构造器。原因：
        1、便于通过反射，创建运行时类的对象
        2、便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器
         */
        Person o = (Person) class1.newInstance();
        System.out.println(o);
**********************************************************************************************************
二、获取运行时类的完整结构：
 /*
    获取当前运行时类的属性结构
     */
    @Test
    public void A() {
        Class<Person> class1 = Person.class;
        //获取属性结构
        //getFields():获取当前运行时类及其父类所有声明位public的属性
        Field[] fields = class1.getFields();
        for (Field field : fields) {
            System.out.println(field);
        }
        //getDeclareFields():获取当前运行时类当中声明的所有属性。（不包含父类中的属性）
        Field[] declaredFields = class1.getDeclaredFields();
        for (Field f : declaredFields) {
            System.out.println(f);
        }
    }

    @Test//权限修饰符 数据类型 变量名
    public void B() {
        Class<Person> p = Person.class;
        Field[] f = p.getDeclaredFields();
        for (Field f1 : f) {
            //权限修饰符
            int i = f1.getModifiers();
            System.out.println(Modifier.toString(i) + "\t");
            //数据类型
            Class<?> type = f1.getType();
            System.out.print(type.getName() + "\t");
            //变量名
            String name = f1.getName();
            System.out.println(name);
            System.out.println();
        }
    }

    /*
    运行时类的方法结构
     */
    @Test
    public void C() {
        Class<Person> p = Person.class;
        //获取所有方法
        //getMethods():获取当前运行时类及其父类所有声明位public的方法
        Method[] m = p.getMethods();
        for (Method a : m) {
            System.out.println(a);
        }
        //getDeclaredMethods():获取当前运行时类中的所有方法。（不包括父类的方法）
        Method[] d = p.getDeclaredMethods();
        for (Method m1:d){
            System.out.println(m1);
        }
    }
********************************************************************************************
  @Test//权限修饰符 数据类型 变量名
    public void B() {
        Class<Person> p = Person.class;
        Field[] f = p.getDeclaredFields();
        for (Field f1 : f) {
            //权限修饰符
            int i = f1.getModifiers();
            System.out.println(Modifier.toString(i) + "\t");
            //数据类型
            Class<?> type = f1.getType();
            System.out.print(type.getName() + "\t");
            //变量名
            String name = f1.getName();
            System.out.println(name);
            System.out.println();
        }
    }

    /*
    运行时类的方法结构
     */
    @Test
    public void C() {
        Class<Person> p = Person.class;
        //获取所有方法
        //getMethods():获取当前运行时类及其父类所有声明位public的方法
        Method[] m = p.getMethods();
        for (Method a : m) {
            System.out.println(a);
        }
        //getDeclaredMethods():获取当前运行时类中的所有方法。（不包括父类的方法）
        Method[] d = p.getDeclaredMethods();
        for (Method m1:d){
            System.out.println(m1);
        }
    }
   @Test//@Xxxx 注释
        // 权限修饰符 返回值类型 方法名(参数类型1 形参1，。。。)throw  XxxException{}
    public void D(){
       Class<Person> c = Person.class;
       Method[] m = c.getMethods();
       for (Method m1:m) {
           //注解
           Annotation[] e = m1.getAnnotations();
           for (Annotation a:e){
               System.out.println(a);
           }
           //权限修饰符
           int m2 = m1.getModifiers();
           System.out.println(Modifier.toString(m2));
          //返回值类型
           System.out.print(m1.getReturnType().getName());
           //方法名
           System.out.print(m1.getName());
           System.out.print("(");
           //形参列表
           Class<?>[] p1 = m1.getParameterTypes();
           if (!(p1==null&&p1.length==0)){
              for (int i=0;i< p1.length;i++){
                  if (i== p1.length-1) {
                      System.out.print(p1[i].getName() + "arg" + i);
                      break;
                  }
                  System.out.print(p1[i]+"arg"+i+",");
              }
           }
           System.out.print(")");
           //异常
           Class<?>[] n = m1.getExceptionTypes();
           if (!(n==null&&n.length==0)){
               System.out.println("throws");
               for (int i=0;i<n.length;i++){
                   if (i==n.length-1){
                       System.out.println(n[i].getName());
                   }
                   System.out.println(n[i].getName()+",");
               }
           }
           System.out.println();
       }
   }
******************************************************************************************************
  Class<Person> p = Person.class;
        //当前运行时类中public的构造器
        Constructor<?>[] c = p.getConstructors();
        for(Constructor i:c){
            System.out.println(i);
        }
        System.out.println();
        //getDeclaredConstructors():获取当前运行时类中声明名的所有构造器
        Constructor<?>[] d = p.getDeclaredConstructors();
        for (Constructor a:d){
            System.out.println(a);
        }
    }
********************************************************************************************************
 /*
    获取构造器结构
     */
    @Test
    public void A() {
        Class<Person> p = Person.class;
        //当前运行时类中public的构造器
        Constructor<?>[] c = p.getConstructors();
        for (Constructor i : c) {
            System.out.println(i);
        }
        System.out.println();
        //getDeclaredConstructors():获取当前运行时类中声明名的所有构造器
        Constructor<?>[] d = p.getDeclaredConstructors();
        for (Constructor a : d) {
            System.out.println(a);
        }
    }
    /*
    运行时类的父类
     */
    @Test
    public void B() {
        Class<Person> p = Person.class;
        //getSuperclass():获取运行时类的父类
        Class<? super Person> s = p.getSuperclass();
        System.out.println(s);
    }
      /*
       运行时类的带泛型父类
       */
    @Test
    public void C() {
        Class<Person> p = Person.class;
        //getSuperclass():获取运行时带泛型类的父类
        Type g = p.getGenericSuperclass();
        System.out.println(g);
    }
    /*
    运行时类的带泛型父类的泛型
    */
    @Test
    public void D() {
        Class<Person> p = Person.class;
        //getSuperclass():获取运行时带泛型类的父类
        Type g = p.getGenericSuperclass();
        ParameterizedType p1= (ParameterizedType) g;
        //获取泛型类型
        Type[] a = p1.getActualTypeArguments();
        for (Type b:a) {
            System.out.println(((Class) b).getTypeName());
        }
    }
*******************************************************************************************************************
 /*
    运行时类的接口
     */
    @Test
    public void E() {
        Class<Person> p = Person.class;
        //运行时类的接口
        Class<?>[] i = p.getInterfaces();
        for (Class c : i) {
            System.out.println(c);
        }
        System.out.println();
        //运行时类的父类的接口
        Class<? super Person> s = p.getSuperclass();
        Class<?>[] a = s.getInterfaces();
        for (Class c : a) {
            System.out.println(c);
        }
    }
    /*
    获取运行时类所在的包
     */
    @Test
    public void N() {
        Class<Person> p = Person.class;
        Package a = p.getPackage();
        System.out.println(a);
    }
    /*
    获取运行时类的注解
     */
    @Test
    public void H() {
        Class<Person> p = Person.class;
        Annotation[] a = p.getAnnotations();
        for (Annotation c : a) {
            System.out.println(c);
        }
    }
*************************************************************************************************************************
三、调用运行时类的指定结构
