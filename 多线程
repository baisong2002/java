一、多线程基础
 程序：是为了完成特定任务、用某种语言编写的一组命令集合。即一段静态代码，静态对象
 进程：是一次程序的执行过程，或者正在运行的一个程序，是一个动态过程。有他自身的（产生、存在、消亡）生命周期，是资源的分配单位，系统在运行时会为每个进程分配不同的内存区域
 线程：是程序内部的一条执行路径，进程细分为线程。
      一进程同一时间并行多个线程，就是支持多线程
     线程作为调度和执行的单位，每个线程拥有独立的栈和程序计数器，线程切换开销小
进程和线程的关系：一个进程可以包含多个线程，至少包含一个线程
二、创建多线程
 方式一：从Thread派生一个自定义类，然后复写run()方法 (自定义一个继承与Thread的子类，复写run（）方法，在main()方法中调用子类的start()方法)
    例子：
public static void main(String[] args) {
	// write your code here
        Person p1=new Person();                   //实例自定义的子类
        p1.start();                               //调用Thread的start()方法（启动Thread，即启动新线程）
        int c=0;                                     /注意：start（）的作用： 
        int d=100;                                          （1）启动当前线程
        System.out.println(c+d);                            （2）调用当前线程的run（）方法
       
    }
}
class Person extends Thread{                     //自定义一个继承与Thread的子类
    @Override                                    //覆写run（）方法
    public void run() {
        for (int a=0;a<=100;a++) {
            if (a % 2 == 0) {
                System.out.println(a);
            }
        }
    }
}
注意：1、不可通过调用run（）方法来启动线程
      2、已经start过的线程不能再次通过同一个对象start，即每个对象只能start一次
 方式二：实现Runable接口的方法
 例子：
public static void main(String[] args) {
	// write your code here
          Test t1=new Test();                       //创建实现类的对象
        Thread t2 = new Thread(t1);                 //将对象作为参数传入Thread类的构造器中，创建Thread类的对象 
        t2.start();                                 //通过Thread类的对象调用start，启动线程。1、启动线程 2、调用当前线程的run()方法
    }
}
class Test implements Runnable{                    //创建一个类并接口于Runable
    @Override                                     //覆写run（）方法
    public void run() {
        for (int a=0;a<100;a++){
            if (a%2==0){
                System.out.println(a);
            }
        }
    }
}
三、多线程常用的方法
1、start()
 (1)启动当前方法
 (2)调用当前线程的run()方法
2、run()
通常需要重写Thread类中的run()方法
将创建的线程需要执行的操作在run()方法中声明
3、currentThread()
静态方法，返回当前代码的线程
4、getName()
获取当前线程的名称
5、setName()
设置当前线程的名称
/*例子：
public static void main(String[] args) {
	// write your code here
        A a=new A();
        a.setName("线程一");
        a.start();
        Thread.currentThread().setName("线程二");
        for (int b=0;b<100;b++){
            if (b%2==0){
                System.out.println(Thread.currentThread().getName()+":"+b);
            }
        }
    }
}
class A extends Thread{
    @Override
    public void run() {
        for (int a=0;a<100;a++){
            if (a%2==0){
                System.out.println(Thread.currentThread().getName()+":"+a);
            }
        }
    }
}
6、yield()
释放当前cpu的执行权
7、join()
在线程A中调用线程B的join()方法，此时线程A进入阻塞状态，直到线程B完全执行完后，线程A才结束阻塞状态
8、stop()
强制线程生命周期结束（当执行线程时，强制结束此线程）
9、sleep(long millitime)
让当前线程“睡眠”millitime毫秒，在指定millitime毫秒内，当前线程是阻塞状态
10、isAlive()
判断线程是否还存活
public static void main(String[] args) {
	// write your code here
        A a=new A();
        a.setName("线程一");
        a.start();
        Thread.currentThread().setName("线程二");
        for (int b=0;b<100;b++){
            if (b%2==0){
                System.out.println(Thread.currentThread().getName()+":"+b);
            }
            if (b==20){
                try {
                    a.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
            System.out.println(a.isAlive());
        }
    }
}
class A extends Thread{
    @Override
    public void run() {
        for (int a=0;a<100;a++){
            if (a%2==0){
                try {
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+":"+a);
            }


        }
    }
}
四、线程优先级
1、线程的优先等级
MAX_PRIORITY:10
MIN_PRIORITY:1
NORM_PRIORITY:5
2、如何获取和设置当前线程的优先级：
  getPriority():获取线程的优先级
  setPriority(int Priority):设置线程的优先级（要在start()之前）
说明：高优先级抢占低优先级的cpu,但并不意味高优先级在执行完成后再执行低优先级